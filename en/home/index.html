<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Igor Ferreira" />
    <meta name="generator" content="Ignite v0.6.0" />
    <title>Home</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/css/prism-github-dark.css" rel="stylesheet" data-highlight-theme="github-dark" />
    <link href="/css/prism-plugins.css" rel="stylesheet" />
    <link href="/css/bootstrap-icons.min.css" rel="stylesheet" />
    <link href="/css/ignite-core.min.css" rel="stylesheet" />
    <link href="https://igorcferreira.dev/en/home" rel="canonical" />
    <meta property="og:site_name" content="Development Blog" />
    <meta property="og:title" content="Home" />
    <meta name="twitter:title" content="Home" />
    <meta property="og:url" content="https://igorcferreira.dev/en/home" />
    <meta name="twitter:domain" content="igorcferreira.dev" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:dnt" content="on" />
    <link href="/apple-touch-icon-precomposed.png" rel="apple-touch-icon" />
    <link href="https://mastodon.social/@igorcferreira" rel="me" />
    <meta name="apple-mobile-web-app-title" content="Development Blog" />
    <meta name="fediverse:creator" content="@igorcferreira@mastodon.social" />
  </head>
  <body class="container">
    <header>
      <nav class="navbar navbar-expand-md" style="background-color: rgb(220 53 69 / 100%)" data-bs-theme="dark">
        <div class="container flex-wrap flex-lg-nowrap">
          <button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
          <div id="navbarCollapse" class="collapse navbar-collapse">
            <ul class="navbar-nav mb-2 mb-md-0 col ">
              <li class="nav-item"><a href="/en/home" class="nav-link active text-nowrap" aria-current="page">Home</a></li>
              <li class="nav-item"><a href="/en/categories" class="nav-link text-nowrap">Categories</a></li>
              <li class="nav-item"><a href="/en/resume" class="nav-link text-nowrap">Resume</a></li>
              <li class="nav-item"><a href="https://github.com/igorcferreira" class="nav-link text-nowrap">GitHub</a></li>
              <li class="nav-item"><a href="https://mastodon.social/@igorcferreira" class="nav-link text-nowrap">Mastodon</a></li>
              <li class="nav-item"><a href="/feed.rss" class="nav-link text-nowrap">Feed</a></li>
              <div class="ms-auto"></div>
              <li class="nav-item"><a href="/pt/home" class="nav-link text-nowrap">Ver em Português</a></li>
            </ul>
          </div>
        </div>
      </nav>
    </header>
    <div class="ig-main-content">
      <div class="card">
        <div class="card-body">
          <h1>StateFlow on KMP and SwiftUI</h1>
          <p>Tagged with: iOS, SwiftUI, KMP, Kotlin</p>
          <p>2102 words; 9 minutes to read</p>
          <p></p>
          <p>The greatest feature with <a href="https://kotlinlang.org/docs/multiplatform.html">Kotlin Multiplatform (KMP)</a> is the possibility to re-use the business logic between platforms, as a separate framework/module while keeping the UI implemented in the native libraries (<a href="https://developer.apple.com/swiftui/">SwiftUI</a> or <a href="https://developer.android.com/compose">Jetpack Compose</a>).</p>
          <p>This way, all the greatest features of the native UI libraries can be used to create amazing native UI/UX with no need to duplicate the business logic which tends to be the same between platforms. Especially when handling Network requests/responses, data validation and model mapping.</p>
          <p>For most of the business logic, this integration is easy and smooth. Even more given that KMP translates Kotlin coroutines into Objective-C closures, correctly layered so it can be auto-translated into Swift concurrency, making the integration with SwiftUI smooth.</p>
          <p>The main problem left is: State maintenance.</p>
          <h2>Example</h2>
          <p>Let’s use a simple example, just to move the debate: An operation class which performs a network request.</p>
          <p>In this thought exercise, the native UI would pass the label, which would be used in a network operation. At the start, simple states would need to be handled: Loading, Success and Error.</p>
          <pre><code class="language-kotlin">class FooOperation(
    private val coroutineScope: CoroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob()),
    private val networkOperation: suspend () -&gt; String = { "Hello World!" }
) {
    sealed class State {
        object None: State()
        object Loading : State()
        data class Error(
            val message: String
        ) : State()
        data class Success(
            val greeting: String
        ) : State()
    }

    private val _state: MutableStateFlow&lt;State&gt; = MutableStateFlow(State.None)
    val state: StateFlow&lt;State&gt; get() = _state.asStateFlow()

    fun perform() = coroutineScope.launch {
        try {
            _state.update { State.Loading }
            //Simulate a network request
            val response = networkOperation()
            _state.update { State.Success(greeting = response) }
        } catch (e: Throwable) {
            _state.update { State.Error(e.message.orEmpty()) }
        }
    }
}
</code></pre>
          <h2>Android usage</h2>
          <p>On Android, the usage of this operation is really simple:</p>
          <pre><code class="language-kotlin">@Composable
fun Foo(
    operation: FooOperation,
    modifier: Modifier = Modifier,
) {
    val state by operation.state.collectAsStateWithLifecycle()
    DisposableEffect(operation) {
        val job = operation.perform()
        onDispose { job.cancel() }
    }
    fun errorState() = state as FooOperation.State.Error
    fun successState() = state as FooOperation.State.Success

    Box(modifier = modifier) {
        when (state) {
            is FooOperation.State.None -&gt; {
                Text("Starting")
            }

            is FooOperation.State.Loading -&gt; {
                Text("Loading...")
            }

            is FooOperation.State.Error -&gt; {
                Text("Error: ${errorState().message}")
            }

            is FooOperation.State.Success -&gt; {
                Text("Success: ${successState().greeting}")
            }
        }
    }
}
</code></pre>
          <p>The <code>DisposableEffect</code> allows us to call the operation on view placement and cancel it if/when the view is removed from the hierarchy. The state is fully controlled by the Operation and the UI reacts to this state change.</p>
          <p>This follows the principles of Clean Architecture of uni-directional state and events. The UI sends events into the business logic and the business logic updates a state. This state changes notifies the UI, which reacts to it and updates accordingly.</p>
          <p>Beautiful.</p>
          <p>On iOS, things are not so easy.</p>
          <h2>iOS usage</h2>
          <p>Without modifying the created <code>FooOperation</code>, the closest that can be done on iOS is:</p>
          <pre><code class="language-swift">struct FooView: View {
    let operation: FooOperation
    @State var state: FooOperation.State

    init(operation: FooOperation) {
        self.operation = operation
        self._state = .init(initialValue: operation.state.value as! FooOperation.State)
    }

    var body: some View {
        Group {
            if (state is FooOperation.StateLoading) {
                Text("Loading...")
            } else if let error = state as? FooOperation.StateError {
                Text("Error: \(error.message)")
            } else if let success = state as? FooOperation.StateSuccess {
                Text("Success: \(success.greeting)")
            } else {
                Text("Starting")
            }
        }
        .padding()
        .task { await load() }
    }

    func load() async {
        self.state = operation.state.value as! FooOperation.State
        let job = operation.perform()
        self.state = operation.state.value as! FooOperation.State
    }
}
</code></pre>
          <p>And this implementation has bugs:</p>
          <ol>
            <li><code>FooOperation.perform()</code> is synchronous. It starts the job, but it returns straight away. So, iOS never receives the final state update.</li>
            <li><code>operation.state.value</code>, when translated into Swift, loses its type. So, iOS is forced to cast the types.</li>
            <li>The initial read of <code>operation.state.value</code> happens before the Operation starts, so it has an invalid/paused state.</li>
          </ol>
          <p>This means the actual business logic written in the Operation class is never used by the UI. The uni-directional state is lost.</p>
          <p>Some changes can be done to minimise the bugs, starting with the <code>FooOperation</code>:</p>
          <pre><code class="language-kotlin">suspend fun execute() {
    try {
        _state.update { State.Loading }
        //Simulate a network request
        val response = networkOperation()
        _state.update { State.Success(greeting = response) }
    } catch (e: Throwable) {
        _state.update { State.Error(e.message.orEmpty()) }
    }
}

fun perform() = coroutineScope.launch {
    execute()
}
</code></pre>
          <p>This change exposes a suspend fun <code>FooOperation.execute()</code>, which is translated into Objective-C as a closure based message, allowing the creation of a swift concurrency wrapper. And the SwiftUI view can be updated into:</p>
          <pre><code class="language-swift">struct FooView: View {
    let operation: FooOperation
    @State var state: FooOperation.State

    init(operation: FooOperation) {
        self.operation = operation
        self._state = .init(initialValue: operation.state.value as! FooOperation.State)
    }

    var body: some View {
        Group {
            if (state is FooOperation.StateLoading) {
                Text("Loading...")
            } else if let error = state as? FooOperation.StateError {
                Text("Error: \(error.message)")
            } else if let success = state as? FooOperation.StateSuccess {
                Text("Success: \(success.greeting)")
            } else {
                Text("Starting")
            }
        }
        .padding()
        .task { await load() }
    }

    func load() async {
        self.state = operation.state.value as! FooOperation.State
        try? await operation.execute()
        self.state = operation.state.value as! FooOperation.State
    }
}
</code></pre>
          <p>By having access to the suspend function completion, the final state of the view is now aligned with the result of the Operation. But, bugs are still present:</p>
          <ol>
            <li><code>operation.state.value</code> still loses type definition.</li>
            <li>The initial read of <code>operation.state.value</code> is still wrong.</li>
            <li>Since <code>suspend</code> functions are converted into Objective-C closures, the CoroutineScope limits are broken.</li>
            <li>Error handling is lost in translation, forcing the Swift code to use <code>try?</code> or replicate error handling in the UI layer.</li>
          </ol>
          <p>And all of this gets even worse if there is more intermediate states in the Operation. For example: File upload; A file upload Operation may need to compress the file, start an upload session, upload the file, and close the session at the end.</p>
          <p>It would be a good UX to update the UI for all these many intermediary states of the operation. Ideally, Swift code needs to listen to state changes in the Flow.</p>
          <p>The async/await wrapper would erase the inner states.</p>
          <p><strong>iOS issues:</strong></p>
          <ol>
            <li>No type-safety in the state values.</li>
            <li>Thread scope disassociation, which prevents Kotlin code from being aware of its threads children.</li>
            <li>No access the intermediary state changes.</li>
            <li>Error handling is lost or duplicated.</li>
          </ol>
          <h2>Thinking out loud</h2>
          <p>I do not have a solution, that is why I propose this post a thought exercise. But, I did something in my <a href="https://github.com/igorcferreira/MusicStreamSync">MusicStreamSync</a> project which allowed me to re-use the business logic for state handling and having the UI reacting to these state changes.</p>
          <p>What I’ll list below is not the most beautiful abstraction, but it is a way to allow us to use the original <code>FooOperation</code> implementation while having the iOS code listening to changes in the state flow.</p>
          <p>A vital tool in achieving the goal of listening to state changes in iOS is the <a href="https://github.com/rickclephas/KMP-NativeCoroutines">KMP-NativeCoroutines</a> project.</p>
          <p>This Kotlin plugin (and Swift Package) enhances the translation of <code>StateFlow</code> from Kotlin coroutines into Swift.</p>
          <p>The 2 main annotations which improve the proposed use-case are <code>@NativeCoroutinesState</code> and <code>@NativeCoroutineScope</code></p>
          <ul>
            <li><strong>NativeCoroutinesState</strong>: Exposes the state value as a type-safe read-only value and creates ways to listen to changes.</li>
            <li><strong>NativeCoroutineScope</strong>: Defines which scope must be used when creating the async/await translations.</li>
          </ul>
          <p>The 4 iOS issues listed above will be handled as:</p>
          <ol>
            <li>No type-safety -&gt; NativeCoroutinesState</li>
            <li>Thread scope disassociation -&gt; NativeCoroutineScope</li>
            <li>No access to the intermediary state -&gt; NativeCoroutinesState</li>
            <li>Error handling is lost or duplicated -&gt; NativeCoroutineScope</li>
          </ol>
          <p><strong>Updated FooOperation:</strong></p>
          <pre><code class="language-kotlin">class FooOperation(
    @NativeCoroutineScope
    private val coroutineScope: CoroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob()),
    private val networkOperation: suspend () -&gt; String = { "Hello World!" }
) {
    sealed class State {
        object None: State()
        object Loading : State()
        data class Error(
            val message: String
        ) : State()
        data class Success(
            val greeting: String
        ) : State()
    }

    private val _state: MutableStateFlow&lt;State&gt; = MutableStateFlow(State.None)
    @NativeCoroutinesState
    val state: StateFlow&lt;State&gt; get() = _state.asStateFlow()

    fun perform() = coroutineScope.launch {
        try {
            _state.update { State.Loading }
            //Simulate a network request
            val response = networkOperation()
            _state.update { State.Success(greeting = response) }
        } catch (e: Throwable) {
            _state.update { State.Error(e.message.orEmpty()) }
        }
    }
}
</code></pre>
          <p><strong>Updated SwiftUI code</strong></p>
          <pre><code class="language-swift">struct FooView: View {
    let operation: FooOperation
    @State var state: FooOperation.State

    init(operation: FooOperation) {
        self.operation = operation
        self._state = .init(initialValue: operation.state)
        self.observe()
    }

    var body: some View {
        Group {
            if (state is FooOperation.StateLoading) {
                Text("Loading...")
            } else if let error = state as? FooOperation.StateError {
                Text("Error: \(error.message)")
            } else if let success = state as? FooOperation.StateSuccess {
                Text("Success: \(success.greeting)")
            } else {
                Text("Starting")
            }
        }
        .padding()
        .task { await load() }
    }

    func observe() {
        Task.detached {
            let flow = await operation.stateFlow
            let sequence = asyncSequence(for: flow)
            for try await output in sequence {
                await update(state: output)
            }
        }
    }
    
    func update(state: FooOperation.State) {
        self.state = state
    }
    
    func load() async {
        operation.perform()
    }
}
</code></pre>
          <p><code>@NativeCoroutinesState</code> allows us to write the <code>FooView.observe()</code> method above. Now, any change of state is propagated into the UI layer, allowing the UI to react to state changes. Now:</p>
          <ol>
            <li>State is type-safe, through the direct access to <code>.state</code>.</li>
            <li>Thread scope is defined through <code>@NativeCoroutineScope</code>. If the <code>Task.detached</code> is cancelled, the <code>asyncSequence</code> closes and if the <code>Job</code> is cancelled, the <code>asyncSequence</code> terminates.</li>
            <li>Intermediary states are now propagated into the UI layer.</li>
            <li>Error handling is bound to the state.</li>
          </ol>
          <p>And the uni-directional state change is now complete. Allowing us to re-use the state management business logic. Great.</p>
          <h2>ViewModel abstraction</h2>
          <p>SwiftUI also has the ViewModel (VM) abstraction, which isolates the state management code out from the View itself, making it easier to test, update and re-use. Applying a VM allows us to clean up the code above into something like:</p>
          <pre><code class="language-swift">@Observable
class FooViewModel {
    private let operation: FooOperation
    var state: FooOperation.State
    
    init(operation: FooOperation) {
        self.operation = operation
        self.state = operation.state
    }
    
    func observe() {
        Task.detached {
            let flow = self.operation.stateFlow
            let sequence = asyncSequence(for: flow)
            for try await output in sequence {
                self.state = output
            }
        }
    }
    
    func start() {
        operation.perform()
    }
}

struct FooView: View {
    @State var vm: FooViewModel
    var state: FooOperation.State {
        vm.state
    }

    init(operation: FooOperation) {
        self.vm = .init(operation: operation)
    }

    var body: some View {
        Group {
            if (state is FooOperation.StateLoading) {
                Text("Loading...")
            } else if let error = state as? FooOperation.StateError {
                Text("Error: \(error.message)")
            } else if let success = state as? FooOperation.StateSuccess {
                Text("Success: \(success.greeting)")
            } else {
                Text("Starting")
            }
        }
        .padding()
        .task { vm.observe() }
    }
}
</code></pre>
          <p>And the <code>observe</code> method can be abstracted using Swift Extensions, into something like:</p>
          <pre><code class="language-swift">extension Observable where Self: AnyObject {
    func collect&lt;Output, Failure: Error&gt;(
        _ flow: @escaping NativeFlow&lt;Output, Failure, KotlinUnit&gt;,
        into path: ReferenceWritableKeyPath&lt;Self, Output&gt;
    ) {
        Task.detached { [weak self] in
            let sequence = asyncSequence(for: flow)
            for try await output in sequence {
                Task.detached { @MainActor in
                    self?[keyPath: path] = output
                }
            }
        }
    }
}

@Observable
class FooViewModel {
    private let operation: FooOperation
    var state: FooOperation.State

    init(operation: FooOperation) {
        self.operation = operation
        self.state = operation.state

        collect(operation.stateFlow, into: \.state)
    }

    func start() {
        operation.perform()
    }
}
</code></pre>
          <h2>Final Note</h2>
          <p>As I said, this post is more a thought exercise than a solution proposal. But, I felt that it was worth to be put into words.</p>
          <p>If you want to give me your opinion, you can find me on <a href="https://mastodon.social/@igorcferreira">Mastodon</a> or <a href="https://bsky.app/profile/igorcferreira.bsky.social">BlueSky</a>.</p>
          <p></p>
        </div>
      </div>
      <div id="accordionOViQz" class="accordion">
        <div class="accordion-item">
          <h2 class="accordion-header"><button type="button" class="accordion-button btn" data-bs-toggle="collapse" data-bs-target="#accordionOViQz-itemAd7R9" aria-expanded="true" aria-controls="accordionOViQz-itemAd7R9">More</button></h2>
          <div id="accordionOViQz-itemAd7R9" class="accordion-collapse collapse show" data-bs-parent="#accordionOViQz">
            <div class="accordion-body">
              <div class="card">
                <div class="card-body">
                  <h2><a href="/en/dynamic-navigation-destionation-link">Using DynamicNavigationDestinationLink</a></h2>
                  <p class="ig-text-xSmall">Tagged with: iOS, SwiftUI</p>
                  <p class="lead">Because of a thread on Twitter, I created this simple gist with an attempt to simulate the use of DynamicNavigationDestinationLink to display a content fetched from an external source, it may be useful for you on trying to find a solution for your crashes.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <p class="text-center mt-5">Created in Swift with <a href="https://github.com/twostraws/Ignite">Ignite</a></p>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/syntax-highlighting.js"></script>
    <script src="/js/ignite-core.js"></script>
  </body>
</html>